// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: stats.sql

package db

import (
	"context"
)

const getAverageStarsByUser = `-- name: GetAverageStarsByUser :one
SELECT
    COALESCE(AVG(star_count), 0) AS average
FROM reviews
WHERE
    reviewed_user_id = $1
`

func (q *Queries) GetAverageStarsByUser(ctx context.Context, reviewedUserID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getAverageStarsByUser, reviewedUserID)
	var average interface{}
	err := row.Scan(&average)
	return average, err
}

const getOfferCount = `-- name: GetOfferCount :one
SELECT
    COALESCE(COUNT(*), 0) AS count
FROM offers
`

func (q *Queries) GetOfferCount(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getOfferCount)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const getOfferCountByCategory = `-- name: GetOfferCountByCategory :many
SELECT skill_categories.category, COALESCE(COUNT(skill_categories.category), 0) AS count
FROM offers
INNER JOIN skills ON offers.skill = skills.skill
INNER JOIN skill_categories ON skills.skill = skill_categories.skill
GROUP BY skill_categories.category
`

type GetOfferCountByCategoryRow struct {
	Category string      `json:"category"`
	Count    interface{} `json:"count"`
}

func (q *Queries) GetOfferCountByCategory(ctx context.Context) ([]*GetOfferCountByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getOfferCountByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOfferCountByCategoryRow
	for rows.Next() {
		var i GetOfferCountByCategoryRow
		if err := rows.Scan(&i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOfferCountBySkill = `-- name: GetOfferCountBySkill :many
SELECT skill, COALESCE(COUNT(*), 0) AS count
FROM offers
GROUP BY skill
`

type GetOfferCountBySkillRow struct {
	Skill string      `json:"skill"`
	Count interface{} `json:"count"`
}

func (q *Queries) GetOfferCountBySkill(ctx context.Context) ([]*GetOfferCountBySkillRow, error) {
	rows, err := q.db.Query(ctx, getOfferCountBySkill)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOfferCountBySkillRow
	for rows.Next() {
		var i GetOfferCountBySkillRow
		if err := rows.Scan(&i.Skill, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOfferCountByUser = `-- name: GetOfferCountByUser :one
SELECT
    COALESCE(COUNT(*), 0) AS count
FROM offers
WHERE
    user_id = $1
`

func (q *Queries) GetOfferCountByUser(ctx context.Context, userID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getOfferCountByUser, userID)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const getReviewCountByStars = `-- name: GetReviewCountByStars :many
SELECT star_count, COALESCE(COUNT(*), 0) AS count
FROM reviews
GROUP BY star_count
`

type GetReviewCountByStarsRow struct {
	StarCount int32       `json:"starCount"`
	Count     interface{} `json:"count"`
}

func (q *Queries) GetReviewCountByStars(ctx context.Context) ([]*GetReviewCountByStarsRow, error) {
	rows, err := q.db.Query(ctx, getReviewCountByStars)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetReviewCountByStarsRow
	for rows.Next() {
		var i GetReviewCountByStarsRow
		if err := rows.Scan(&i.StarCount, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewCountByUser = `-- name: GetReviewCountByUser :one
SELECT
    COALESCE(COUNT(*), 0) AS count
FROM reviews
WHERE reviewing_user_id = $1
`

func (q *Queries) GetReviewCountByUser(ctx context.Context, reviewingUserID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getReviewCountByUser, reviewingUserID)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const getUserCount = `-- name: GetUserCount :one
SELECT
    COALESCE(COUNT(*), 0) AS count
FROM users
`

func (q *Queries) GetUserCount(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserCount)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

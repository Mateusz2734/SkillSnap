// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: offers.sql

package db

import (
	"context"
)

const addOffer = `-- name: AddOffer :one
INSERT INTO offers (user_id, skill, description)
VALUES
    ($1, $2, $3) RETURNING created_at, offer_id, user_id, skill, description
`

type AddOfferParams struct {
	UserID      int32
	Skill       string
	Description string
}

func (q *Queries) AddOffer(ctx context.Context, arg AddOfferParams) (Offer, error) {
	row := q.db.QueryRow(ctx, addOffer, arg.UserID, arg.Skill, arg.Description)
	var i Offer
	err := row.Scan(
		&i.CreatedAt,
		&i.OfferID,
		&i.UserID,
		&i.Skill,
		&i.Description,
	)
	return i, err
}

const deleteOffer = `-- name: DeleteOffer :exec
DELETE FROM
    offers
WHERE
    offer_id = $1
`

func (q *Queries) DeleteOffer(ctx context.Context, offerID int32) error {
	_, err := q.db.Exec(ctx, deleteOffer, offerID)
	return err
}

const getOfferById = `-- name: GetOfferById :one
SELECT
    created_at, offer_id, user_id, skill, description
FROM offers
WHERE
    offer_id = $1
`

func (q *Queries) GetOfferById(ctx context.Context, offerID int32) (Offer, error) {
	row := q.db.QueryRow(ctx, getOfferById, offerID)
	var i Offer
	err := row.Scan(
		&i.CreatedAt,
		&i.OfferID,
		&i.UserID,
		&i.Skill,
		&i.Description,
	)
	return i, err
}

const getOffers = `-- name: GetOffers :many
SELECT
    created_at, offer_id, user_id, skill, description
FROM offers
LIMIT $1
OFFSET $2
`

type GetOffersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetOffers(ctx context.Context, arg GetOffersParams) ([]Offer, error) {
	rows, err := q.db.Query(ctx, getOffers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Offer
	for rows.Next() {
		var i Offer
		if err := rows.Scan(
			&i.CreatedAt,
			&i.OfferID,
			&i.UserID,
			&i.Skill,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffersByCategory = `-- name: GetOffersByCategory :many
SELECT
    created_at,
    offer_id,
    user_id,
    offers.skill,
    description
FROM offers
INNER JOIN skills ON offers.skill = skills.skill
INNER JOIN skill_categories ON skills.skill = skill_categories.skill
WHERE skill_categories.category = $1
LIMIT $2
OFFSET $3
`

type GetOffersByCategoryParams struct {
	Category string
	Limit    int32
	Offset   int32
}

func (q *Queries) GetOffersByCategory(ctx context.Context, arg GetOffersByCategoryParams) ([]Offer, error) {
	rows, err := q.db.Query(ctx, getOffersByCategory, arg.Category, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Offer
	for rows.Next() {
		var i Offer
		if err := rows.Scan(
			&i.CreatedAt,
			&i.OfferID,
			&i.UserID,
			&i.Skill,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffersByUser = `-- name: GetOffersByUser :many
SELECT
    created_at, offer_id, user_id, skill, description
FROM offers
WHERE
    user_id = $1
`

func (q *Queries) GetOffersByUser(ctx context.Context, userID int32) ([]Offer, error) {
	rows, err := q.db.Query(ctx, getOffersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Offer
	for rows.Next() {
		var i Offer
		if err := rows.Scan(
			&i.CreatedAt,
			&i.OfferID,
			&i.UserID,
			&i.Skill,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
